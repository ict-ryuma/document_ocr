```json
{
  "files": [
    {
      "path": "rails_app/db/schema.rb",
      "content": "# This file is auto-generated from the current state of the database. Instead\n# of editing this file, please use the migrations feature of Active Record to\n# incrementally modify your database, and then regenerate this schema definition.\n#\n# This file is the source Rails uses to define your schema when running `bin/rails\n# db:schema:load`. When creating a new database, `bin/rails db:schema:load` tends to\n# be faster and is potentially less error prone than running all of your\n# migrations from scratch. Old migrations may fail to apply correctly if those\n# migrations use external dependencies or application code.\n#\n# It's strongly recommended that you check this file into your version control system.\n\nActiveRecord::Schema[7.1].define(version: 2024_01_15_000002) do\n  create_table \"estimates\", force: :cascade do |t|\n    t.string \"vendor_name\"\n    t.date \"estimate_date\"\n    t.integer \"total_excl_tax\"\n    t.integer \"total_incl_tax\"\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n  end\n\n  create_table \"estimate_items\", force: :cascade do |t|\n    t.integer \"estimate_id\", null: false\n    t.string \"item_name_raw\"\n    t.string \"item_name_norm\"\n    t.string \"cost_type\"\n    t.integer \"amount_excl_tax\"\n    t.datetime \"created_at\", null: false\n    t.datetime \"updated_at\", null: false\n    t.index [\"estimate_id\"], name: \"index_estimate_items_on_estimate_id\"\n    t.index [\"item_name_norm\"], name: \"index_estimate_items_on_item_name_norm\"\n  end\n\n  add_foreign_key \"estimate_items\", \"estimates\"\nend\n"
    },
    {
      "path": "rails_app/app/models/estimate.rb",
      "content": "class Estimate < ApplicationRecord\n  has_many :estimate_items, dependent: :destroy\n\n  validates :vendor_name, presence: true\n  validates :estimate_date, presence: true\n  validates :total_excl_tax, presence: true, numericality: { only_integer: true, greater_than_or_equal_to: 0 }\n  validates :total_incl_tax, presence: true, numericality: { only_integer: true, greater_than_or_equal_to: 0 }\n\n  def items_count\n    estimate_items.count\n  end\n\n  def as_json(options = {})\n    super(options.merge(methods: [:items_count]))\n  end\nend\n"
    },
    {
      "path": "rails_app/app/models/estimate_item.rb",
      "content": "class EstimateItem < ApplicationRecord\n  belongs_to :estimate\n\n  validates :item_name_raw, presence: true\n  validates :item_name_norm, presence: true\n  validates :cost_type, presence: true, inclusion: { in: %w[parts labor] }\n  validates :amount_excl_tax, presence: true, numericality: { only_integer: true, greater_than_or_equal_to: 0 }\n\n  scope :by_normalized_item, ->(item_name) { where(item_name_norm: item_name) }\n  scope :parts_only, -> { where(cost_type: 'parts') }\n  scope :labor_only, -> { where(cost_type: 'labor') }\nend\n"
    },
    {
      "path": "rails_app/app/controllers/estimates_controller.rb",
      "content": "class EstimatesController < ApplicationController\n  # POST /estimates/from_pdf\n  # Body: {\"pdf_path\": \"../dummy.pdf\"}\n  def from_pdf\n    pdf_path = params[:pdf_path]\n\n    if pdf_path.blank?\n      return render json: { error: 'pdf_path is required' }, status: :bad_request\n    end\n\n    importer = EstimateImporter.new(pdf_path)\n    result = importer.import\n\n    if result[:error]\n      render json: { error: result[:error] }, status: :unprocessable_entity\n    else\n      render json: { estimate_id: result[:estimate].id }, status: :created\n    end\n  rescue => e\n    render json: { error: \"Import failed: #{e.message}\" }, status: :internal_server_error\n  end\n\n  # GET /estimates\n  def index\n    estimates = Estimate.includes(:estimate_items).order(estimate_date: :desc)\n\n    render json: estimates.map { |est|\n      {\n        id: est.id,\n        vendor_name: est.vendor_name,\n        estimate_date: est.estimate_date,\n        total_excl_tax: est.total_excl_tax,\n        total_incl_tax: est.total_incl_tax,\n        items_count: est.estimate_items.count,\n        created_at: est.created_at\n      }\n    }\n  end\nend\n"
    },
    {
      "path": "rails_app/app/controllers/recommendations_controller.rb",
      "content": "class RecommendationsController < ApplicationController\n  # GET /recommendations/by_item?item=wiper_blade\n  def by_item\n    item_name = params[:item]\n\n    if item_name.blank?\n      return render json: { error: 'item parameter is required' }, status: :bad_request\n    end\n\n    query_service = EstimatePriceQuery.new(item_name)\n    result = query_service.execute\n\n    if result[:error]\n      render json: { error: result[:error] }, status: :not_found\n    else\n      render json: result\n    end\n  rescue => e\n    render json: { error: \"Query failed: #{e.message}\" }, status: :internal_server_error\n  end\nend\n"
    },
    {
      "path": "rails_app/app/controllers/kintone_controller.rb",
      "content": "class KintoneController < ApplicationController\n  # POST /kintone/push?item=wiper_blade\n  def push\n    item_name = params[:item]\n\n    if item_name.blank?\n      return render json: { error: 'item parameter is required' }, status: :bad_request\n    end\n\n    # Compute recommendations\n    query_service = EstimatePriceQuery.new(item_name)\n    recommendations = query_service.execute\n\n    if recommendations[:error]\n      return render json: { error: recommendations[:error] }, status: :not_found\n    end\n\n    # Push to kintone\n    kintone_client = KintoneClient.new\n    result = kintone_client.push_recommendation(item_name, recommendations)\n\n    if result[:error]\n      render json: { error: result[:error] }, status: :unprocessable_entity\n    else\n      render json: { kintone_record_id: result[:record_id] }, status: :created\n    end\n  rescue => e\n    render json: { error: \"Kintone push failed: #{e.message}\" }, status: :internal_server_error\n  end\nend\n"
    },
    {
      "path": "rails_app/app/controllers/nl_controller.rb",
      "content": "class NlController < ApplicationController\n  # GET /nl/query?q=一番安いワイパーブレード\n  def query\n    query_text = params[:q]\n\n    if query_text.blank?\n      return render json: { error: 'q parameter is required' }, status: :bad_request\n    end\n\n    # Simple rule-based mapping (no LLM for MVP)\n    item_name = extract_item_name(query_text)\n\n    if item_name.nil? || !query_text.include?('一番安い')\n      return render json: { error: 'unsupported query' }, status: :bad_request\n    end\n\n    # Delegate to recommendations logic\n    query_service = EstimatePriceQuery.new(item_name)\n    result = query_service.execute\n\n    if result[:error]\n      render json: { error: result[:error] }, status: :not_found\n    else\n      render json: result\n    end\n  rescue => e\n    render json: { error: \"NL query failed: #{e.message}\" }, status: :internal_server_error\n  end\n\n  private\n\n  def extract_item_name(text)\n    # Simple keyword matching for MVP\n    if text =~ /(ワイパー|wiper|ブレード|blade)/i\n      return 'wiper_blade'\n    end\n\n    nil\n  end\nend\n"
    },
    {
      "path": "rails_app/app/services/estimate_importer.rb",
      "content": "require 'json'\nrequire 'open3'\n\nclass EstimateImporter\n  def initialize(pdf_path)\n    @pdf_path = pdf_path\n  end\n\n  def import\n    # Call Python engine\n    python_result = call_python_engine\n\n    if python_result[:error]\n      return { error: python_result[:error] }\n    end\n\n    parsed_data = python_result[:data]\n\n    # Persist to database\n    estimate = nil\n    ActiveRecord::Base.transaction do\n      estimate = Estimate.create!(\n        vendor_name: parsed_data['vendor_name'],\n        estimate_date: Date.parse(parsed_data['estimate_date']),\n        total_excl_tax: parsed_data['total_excl_tax'],\n        total_incl_tax: parsed_data['total_incl_tax']\n      )\n\n      parsed_data['items'].each do |item|\n        estimate.estimate_items.create!(\n          item_name_raw: item['item_name_raw'],\n          item_name_norm: item['item_name_norm'],\n          cost_type: item['cost_type'],\n          amount_excl_tax: item['amount_excl_tax']\n        )\n      end\n    end\n\n    { estimate: estimate }\n  rescue => e\n    { error: \"Database error: #{e.message}\" }\n  end\n\n  private\n\n  def call_python_engine\n    python_script = Rails.root.join('..', 'python_engine', 'main.py').to_s\n    cmd = \"python3 #{python_script} --pdf #{@pdf_path}\"\n\n    stdout, stderr, status = Open3.capture3(cmd)\n\n    unless status.success?\n      return { error: \"Python engine failed: #{stderr}\" }\n    end\n\n    begin\n      data = JSON.parse(stdout)\n      if data['error']\n        return { error: data['error'] }\n      end\n      { data: data }\n    rescue JSON::ParserError => e\n      { error: \"Invalid JSON from Python engine: #{e.message}\" }\n    end\n  end\nend\n"
    }
  ],
  "notes": "Schema includes indexes for performance. Models have validations and associations. Controllers handle MVP endpoints with error handling. EstimateImporter calls Python via shell and persists data. NL controller uses simple keyword matching without LLM."
}
```
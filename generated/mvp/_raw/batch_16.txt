```json
{
  "files": [
    {
      "path": "rails_app/app/services/estimate_price_query.rb",
      "content": "class EstimatePriceQuery\n  def initialize(item_name_norm)\n    @item_name_norm = item_name_norm\n  end\n\n  def call\n    items = EstimateItem.where(item_name_norm: @item_name_norm)\n    return { error: \"No items found for #{@item_name_norm}\" } if items.empty?\n\n    estimate_ids = items.pluck(:estimate_id).uniq\n    estimates = Estimate.where(id: estimate_ids)\n\n    single_vendor_best = calculate_single_vendor_best(items, estimates)\n    split_best = calculate_split_best(items)\n    totals_per_estimate = calculate_totals_per_estimate(items, estimates)\n\n    {\n      single_vendor_best: single_vendor_best,\n      split_theoretical_best: split_best,\n      totals_per_estimate: totals_per_estimate\n    }\n  end\n\n  private\n\n  def calculate_single_vendor_best(items, estimates)\n    grouped = items.group_by(&:estimate_id)\n    best = grouped.map do |estimate_id, est_items|\n      total = est_items.sum(&:amount_excl_tax)\n      estimate = estimates.find { |e| e.id == estimate_id }\n      {\n        estimate_id: estimate_id,\n        vendor_name: estimate&.vendor_name,\n        total: total\n      }\n    end.min_by { |x| x[:total] }\n\n    best\n  end\n\n  def calculate_split_best(items)\n    parts_items = items.where(cost_type: 'parts')\n    labor_items = items.where(cost_type: 'labor')\n\n    parts_min = parts_items.minimum(:amount_excl_tax) || 0\n    labor_min = labor_items.minimum(:amount_excl_tax) || 0\n\n    {\n      parts_min: parts_min,\n      labor_min: labor_min,\n      total: parts_min + labor_min\n    }\n  end\n\n  def calculate_totals_per_estimate(items, estimates)\n    grouped = items.group_by(&:estimate_id)\n    totals = grouped.map do |estimate_id, est_items|\n      total = est_items.sum(&:amount_excl_tax)\n      estimate = estimates.find { |e| e.id == estimate_id }\n      {\n        estimate_id: estimate_id,\n        vendor_name: estimate&.vendor_name,\n        total: total\n      }\n    end\n\n    totals.sort_by { |x| x[:total] }\n  end\nend"
    },
    {
      "path": "rails_app/app/services/kintone_client.rb",
      "content": "require 'net/http'\nrequire 'json'\nrequire 'uri'\n\nclass KintoneClient\n  def initialize\n    @domain = ENV['KINTONE_DOMAIN']\n    @token = ENV['KINTONE_API_TOKEN']\n    @app_id = 316\n  end\n\n  def push_recommendation(item_name_norm, recommendation_data)\n    uri = URI(\"https://#{@domain}/k/v1/record.json\")\n    http = Net::HTTP.new(uri.host, uri.port)\n    http.use_ssl = true\n\n    request = Net::HTTP::Post.new(uri.path)\n    request['X-Cybozu-API-Token'] = @token\n    request['Content-Type'] = 'application/json'\n\n    record = build_record(item_name_norm, recommendation_data)\n    body = {\n      app: @app_id,\n      record: record\n    }\n\n    request.body = body.to_json\n\n    response = http.request(request)\n    result = JSON.parse(response.body)\n\n    if response.code.to_i >= 200 && response.code.to_i < 300\n      { success: true, kintone_record_id: result['id'] }\n    else\n      { success: false, error: result['message'] || 'Unknown error' }\n    end\n  rescue => e\n    { success: false, error: e.message }\n  end\n\n  private\n\n  def build_record(item_name_norm, recommendation_data)\n    single = recommendation_data[:single_vendor_best] || {}\n    split = recommendation_data[:split_theoretical_best] || {}\n\n    {\n      item_name: { value: item_name_norm },\n      best_vendor: { value: single[:vendor_name] || '' },\n      best_single_total: { value: single[:total] || 0 },\n      split_parts_min: { value: split[:parts_min] || 0 },\n      split_labor_min: { value: split[:labor_min] || 0 },\n      split_total: { value: split[:total] || 0 }\n    }\n  end\nend"
    },
    {
      "path": "rails_app/README.md",
      "content": "# Rails Estimate Parser MVP\n\nRails API + Python PDF parser + kintone integration.\n\n## Prerequisites\n\n- Ruby 3.x\n- Rails 7.x\n- Python 3.x\n- SQLite3\n\n## Setup\n\n```bash\ncd rails_app\nbundle install\nrails db:create db:migrate\n\n# Optional: seed sample data\nruby script/seed_sample.rb\n\n# Set environment variables\nexport KINTONE_DOMAIN=\"your-subdomain.cybozu.com\"\nexport KINTONE_API_TOKEN=\"your-api-token\"\n```\n\n## Run Server\n\n```bash\nrails server\n```\n\n## API Endpoints\n\n### 1. Parse PDF and Create Estimate\n\n```bash\ncurl -X POST http://localhost:3000/estimates/from_pdf \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"pdf_path\":\"../dummy.pdf\"}'\n```\n\nResponse:\n```json\n{\"estimate_id\": 1}\n```\n\n### 2. Get Recommendations by Item\n\n```bash\ncurl \"http://localhost:3000/recommendations/by_item?item=wiper_blade\"\n```\n\nResponse:\n```json\n{\n  \"single_vendor_best\": {\n    \"estimate_id\": 1,\n    \"vendor_name\": \"AutoShop A\",\n    \"total\": 8500\n  },\n  \"split_theoretical_best\": {\n    \"parts_min\": 3500,\n    \"labor_min\": 2000,\n    \"total\": 5500\n  },\n  \"totals_per_estimate\": [\n    {\"estimate_id\": 1, \"vendor_name\": \"AutoShop A\", \"total\": 8500},\n    {\"estimate_id\": 2, \"vendor_name\": \"AutoShop B\", \"total\": 9200}\n  ]\n}\n```\n\n### 3. Push to kintone\n\n```bash\ncurl -X POST \"http://localhost:3000/kintone/push?item=wiper_blade\"\n```\n\nResponse:\n```json\n{\"kintone_record_id\": \"12345\"}\n```\n\n### 4. List All Estimates\n\n```bash\ncurl \"http://localhost:3000/estimates\"\n```\n\nResponse:\n```json\n[\n  {\n    \"id\": 1,\n    \"vendor_name\": \"AutoShop A\",\n    \"estimate_date\": \"2025-01-15\",\n    \"total_excl_tax\": 50000,\n    \"total_incl_tax\": 55000,\n    \"items_count\": 5\n  }\n]\n```\n\n### 5. Natural Language Query (MVP stub)\n\n```bash\ncurl \"http://localhost:3000/nl/query?q=ワイパーで一番安いのは\"\n```\n\nResponse: Same as `/recommendations/by_item?item=wiper_blade`\n\n```bash\ncurl \"http://localhost:3000/nl/query?q=エンジンオイル交換\"\n```\n\nResponse:\n```json\n{\"error\": \"unsupported query\"}\n```\n\n## Python Engine\n\nSee `../python_engine/README.md` for details.\n\n## Database Schema\n\n**estimates**\n- vendor_name: string\n- estimate_date: date\n- total_excl_tax: integer\n- total_incl_tax: integer\n\n**estimate_items**\n- estimate_id: references\n- item_name_raw: string\n- item_name_norm: string\n- cost_type: string (parts/labor)\n- amount_excl_tax: integer\n\n## Notes\n\n- Python engine is stateless (no DB/file writes)\n- Item normalization: ワイパー/wiper/ブレード → wiper_blade\n- Cost type: includes 工賃 → labor, else parts\n- kintone app_id = 316"
    },
    {
      "path": "rails_app/script/seed_sample.rb",
      "content": "#!/usr/bin/env ruby\n\nrequire_relative '../config/environment'\n\nActiveRecord::Base.transaction do\n  # Create Estimate #1\n  estimate1 = Estimate.create!(\n    vendor_name: 'AutoShop A',\n    estimate_date: Date.parse('2025-01-15'),\n    total_excl_tax: 50000,\n    total_incl_tax: 55000\n  )\n\n  EstimateItem.create!(\n    estimate: estimate1,\n    item_name_raw: 'ワイパーブレード',\n    item_name_norm: 'wiper_blade',\n    cost_type: 'parts',\n    amount_excl_tax: 3500\n  )\n\n  EstimateItem.create!(\n    estimate: estimate1,\n    item_name_raw: 'ワイパー交換工賃',\n    item_name_norm: 'wiper_blade',\n    cost_type: 'labor',\n    amount_excl_tax: 2000\n  )\n\n  EstimateItem.create!(\n    estimate: estimate1,\n    item_name_raw: 'エンジンオイル',\n    item_name_norm: 'engine_oil',\n    cost_type: 'parts',\n    amount_excl_tax: 4500\n  )\n\n  EstimateItem.create!(\n    estimate: estimate1,\n    item_name_raw: 'オイル交換工賃',\n    item_name_norm: 'engine_oil',\n    cost_type: 'labor',\n    amount_excl_tax: 1500\n  )\n\n  # Create Estimate #2\n  estimate2 = Estimate.create!(\n    vendor_name: 'AutoShop B',\n    estimate_date: Date.parse('2025-01-16'),\n    total_excl_tax: 52000,\n    total_incl_tax: 57200\n  )\n\n  EstimateItem.create!(\n    estimate: estimate2,\n    item_name_raw: 'Wiper Blade Premium',\n    item_name_norm: 'wiper_blade',\n    cost_type: 'parts',\n    amount_excl_tax: 4200\n  )\n\n  EstimateItem.create!(\n    estimate: estimate2,\n    item_name_raw: 'Wiper installation labor',\n    item_name_norm: 'wiper_blade',\n    cost_type: 'labor',\n    amount_excl_tax: 2500\n  )\n\n  EstimateItem.create!(\n    estimate: estimate2,\n    item_name_raw: 'Synthetic Engine Oil',\n    item_name_norm: 'engine_oil',\n    cost_type: 'parts',\n    amount_excl_tax: 5800\n  )\n\n  EstimateItem.create!(\n    estimate: estimate2,\n    item_name_raw: 'Oil change service',\n    item_name_norm: 'engine_oil',\n    cost_type: 'labor',\n    amount_excl_tax: 1800\n  )\n\n  puts \"✓ Created 2 estimates with items\"\n  puts \"  Estimate #1 (AutoShop A): #{estimate1.estimate_items.count} items\"\n  puts \"  Estimate #2 (AutoShop B): #{estimate2.estimate_items.count} items\"\nend"
    },
    {
      "path": "python_engine/main.py",
      "content": "#!/usr/bin/env python3\nimport sys\nimport json\nimport os\nimport argparse\nfrom datetime import date\n\ndef normalize_item_name(raw_name):\n    \"\"\"\n    Normalize item names according to MVP rules.\n    \"\"\"\n    lower = raw_name.lower()\n    \n    # Wiper blade normalization\n    if any(keyword in lower for keyword in ['ワイパー', 'wiper', 'ブレード', 'blade']):\n        return 'wiper_blade'\n    \n    # Engine oil normalization\n    if any(keyword in lower for keyword in ['エンジンオイル', 'engine oil', 'oil']):\n        return 'engine_oil'\n    \n    # Default: use raw name with spaces replaced\n    return raw_name.lower().replace(' ', '_').replace('　', '_')\n\ndef determine_cost_type(item_name_raw):\n    \"\"\"\n    Determine if item is parts or labor.\n    If name includes 工賃 or 'labor' or 'installation' -> labor\n    Otherwise -> parts\n    \"\"\"\n    lower = item_name_raw.lower()\n    if any(keyword in lower for keyword in ['工賃', 'labor', 'installation', 'service']):\n        return 'labor'\n    return 'parts'\n\ndef parse_pdf(pdf_path):\n    \"\"\"\n    MVP PDF parser (stateless).\n    - If file doesn't exist: return error\n    - If file exists: return sample/dummy data\n    \"\"\"\n    if not os.path.exists(pdf_path):\n        return {\"error\": f\"File not found: {pdf_path}\"}\n    \n    # For MVP: return fixed sample data\n    raw_items = [\n        {\"name\": \"ワイパーブレード\", \"amount\": 3800},\n        {\"name\": \"ワイパー交換工賃\", \"amount\": 2200},\n        {\"name\": \"エンジンオイル 5W-30\", \"amount\": 4800},\n        {\"name\": \"オイル交換工賃\", \"amount\": 1500},\n        {\"name\": \"エアフィルター\", \"amount\": 2800}\n    ]\n    \n    items = []\n    for raw_item in raw_items:\n        normalized = normalize_item_name(raw_item[\"name\"])\n        cost_type = determine_cost_type(raw_item[\"name\"])\n        items.append({\n            \"item_name_raw\": raw_item[\"name\"],\n            \"item_name_norm\": normalized,\n            \"cost_type\": cost_type,\n            \"amount_excl_tax\": raw_item[\"amount\"]\n        })\n    \n    total_excl_tax = sum(item[\"amount_excl_tax\"] for item in items)\n    total_incl_tax = int(total_excl_tax * 1.1)\n    \n    result = {\n        \"vendor_name\": \"Sample Auto Shop\",\n        \"estimate_date\": date.today().isoformat(),\n        \"total_excl_tax\": total_excl_tax,\n        \"total_incl_tax\": total_incl_tax,\n        \"items\": items\n    }\n    \n    return result\n\ndef main():\n    parser = argparse.ArgumentParser(description='PDF Estimate Parser')\n    parser.add_argument('--pdf', required=True, help='Path to PDF file')\n    args = parser.parse_args()\n    \n    result = parse_pdf(args.pdf)\n    print(json.dumps(result, ensure_ascii=False, indent=2))\n    sys.exit(0)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "path": "python_engine/README.md",
      "content": "# Python PDF Parser Engine\n\nStateless PDF parser for automotive estimate PDFs.\n\n## Responsibilities\n\n- Parse PDF and extract estimate data\n- Normalize item names (e.g., ワイパー/wiper/ブレード → wiper_blade)\n- Determine cost type (parts vs labor)\n- Output JSON to stdout\n- **NO database access**\n- **NO kintone calls**\n- **NO file writes**\n\n## Usage\n\n```bash\npython3 main.py --pdf /path/to/estimate.pdf\n```\n\n## Output Format\n\n### Success\n\n```json\n{\n  \"vendor_name\": \"Sample Auto Shop\",\n  \"estimate_date\": \"2025-01-15\",\n  \"total_excl_tax\": 15100,\n  \"total_incl_tax\": 16610,\n  \"items\": [\n    {\n      \"item_name_raw\": \"ワイパーブレード\",\n      \"item_name_norm\": \"wiper_blade\",\n      \"cost_type\": \"parts\",\n      \"amount_excl_tax\": 3800\n    },\n    {\n      \"item_name_raw\": \"ワイパー交換工賃\",\n      \"item_name_norm\": \"wiper_blade\",\n      \"cost_type\": \"labor\",\n      \"amount_excl_tax\": 2200\n    }\n  ]\n}\n```\n\n### Error (file not found)\n\n```json\n{\n  \"error\": \"File not found: /path/to/missing.pdf\"\n}\n```\n\n## Normalization Rules\n\n### Item Names\n\n- ワイパー / wiper / ブレード / blade → `wiper_blade`\n- エンジンオイル / engine oil / oil → `engine_oil`\n- Other items: lowercase with underscores\n\n### Cost Type\n\n- Contains 工賃 / labor / installation / service → `labor`\n- Otherwise → `parts`\n\n## MVP Behavior\n\n- If PDF file exists but is empty/dummy: returns sample data with 5 items\n- If PDF file doesn't exist: returns error JSON and exits with code 0\n- No actual PDF parsing in MVP - uses fixed sample data\n\n## Dependencies\n\n- Python 3.6+\n- Standard library only (no external packages for MVP)\n\n## Future Enhancements\n\n- Actual PDF parsing with PyPDF2 or pdfplumber\n- OCR support for scanned PDFs\n- More sophisticated item name normalization\n- Multi-vendor format support"
    }
  ],
  "notes": "Complete MVP services, README with curl examples, seed script, and Python engine with normalization logic."
}
```